# lab1 SPOC思考题

## **提前准备**
（请在上课前完成）

 - 完成lec4的视频学习和提交对应的在线练习
 - git pull ucore_os_lab, v9_cpu, os_course_spoc_exercises in github repos。这样可以在本机上完成课堂练习。
 - 了解x86的保护模式，段选择子，全局描述符，全局描述符表，中断描述符表等概念，以及如何读写，设置等操作
 - 了解Linux中的ELF执行文件格式
 - 了解外设:串口，并口，时钟，键盘,CGA，已经如何对这些外设进行编程
 - 了解x86架构中的mem地址空间和io地址空间
 - 了解x86的中断处理过程（包括硬件部分和软件部分）
 - 了解GCC内联汇编
 - 了解C语言的可函数变参数编程
 - 了解qemu的启动参数的含义
 - 在piazza上就lec3学习中不理解问题进行提问
 - 学会使用 qemu
 - 在linux系统中，看看 /proc/cpuinfo的内容

## 思考题

### 启动顺序

1. 段寄存器的字段含义和功能有哪些？

    > 这里对“段寄存器”的理解为IA-32手册中的"Segment Register"。字段：Selector-段选择子，包括段索引index，段表标识（GDT/LDT），段访问的请求权限RPL；Base-段基址，即段的起始地址；Limit：段长度限制。

2. 描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么？在哪些寄存器中存在这些字段？对应的访问条件是什么？

    > 1. CPL是当前进程的权限级别(Current Privilege Level)，是当前正在执行的代码所在的段的特权级，存在于 **CS寄存器** 的低两位。
    > 2. RPL说明的是进程对段访问的请求权限(Request Privilege Level)，存在于 **段选择子** 中，每个段选择子有自己的RPL，它说明的是进程对段访问的请求权限，类似函数参数。而且RPL对每个段来说不是固定的，两次访问同一段时的RPL可以不同。RPL可能会削弱CPL的作用，例如当前CPL=0的进程要访问一个数据段，它把段选择符中的RPL设为3，这样虽然它对该段仍然只有特权为3的访问权限。
    > 3. DPL存储在  **段描述符** 中，规定访问该段的权限级别(Descriptor Privilege Level)，每个段的DPL固定。

3. 分析可执行文件格式elf的格式（无需回答）

### 4.2 C函数调用的实现

### 4.4 x86中断处理过程

1. 中断处理中硬件压栈内容？用户态中断和内核态中断的硬件压栈有什么不同？
    > 1. 内核态中断硬件压栈：eflags, CS, EIP, 错误码(若无则压入0)；
    > 2. 用户态中断时，在eflags压栈之前还要将SS和ESP压栈

2. 为什么在用户态的中断响应要使用内核堆栈？
    > 因为中断响应需要执行内核态指令，用内核态栈可以保护中断服务例程的代码安全。

3. trap类型的中断门与interrupt类型的中断门有啥设置上的差别？如果在设置中断门上不做区分，会有什么可能的后果?
    > - interrupt类型中断门会清理IF标志关中断，而且DPL为0，用户态无法访问；trap类型中断门维持IF标志位不变，即不关中断。
    > - 因为interrupt产生时，经常会出现屏蔽低等级中断的情况，但trap时则不会屏蔽中断。若不区分则无法达到上述目标，导致中断屏蔽失效。

### 4.8 练习四和五 ucore内核映像加载和函数调用栈分析

1. 在kdebug.c文件中用到的函数`read_ebp`是内联的，而函数`read_eip`不是内联的。为什么要设计成这样？
    > 因为`read_eip()`函数获取%eip的方法是利用函数调用过程建立调用栈，用`(%ebp + 4)`即函数的返回地址获取当前eip的值，因此不能内联，必须执行函数调用过程。相反，当要读取ebp的值时，则不能发生函数调用过程，否则会改变ebp的值，因此必须设计成内联函数。

### 4.9 练习六 完善中断初始化和处理

1. CPU加电初始化后中断是使能的吗？为什么？
    > 不是，因为这时还没有执行BIOS代码，中断向量表还未填充，还不知道该如何处理异常。

## 开放思考题

1. 如何修改lab1, 实现在出现除零异常时显示一个字符串的异常服务例程？
2. 在lab1/bin目录下，通过`objcopy -O binary kernel kernel.bin`可以把elf格式的ucore kernel转变成体积更小巧的binary格式的ucore kernel。为此，需要如何修改lab1的bootloader, 能够实现正确加载binary格式的ucore OS？ (hard)
3. GRUB是一个通用的bootloader，被用于加载多种操作系统。如果放弃lab1的bootloader，采用GRUB来加载ucore OS，请问需要如何修改lab1, 能够实现此需求？ (hard)
4. 如果没有中断，操作系统设计会有哪些问题或困难？在这种情况下，能否完成对外设驱动和对进程的切换等操作系统核心功能？

## 课堂实践
### 练习一
在Linux系统的应用程序中写一个函数print_stackframe()，用于获取当前位置的函数调用栈信息。实现如下一种或多种功能：函数入口地址、函数名信息、参数调用参数信息、返回值信息。

### 练习二
在ucore内核中写一个函数print_stackframe()，用于获取当前位置的函数调用栈信息。实现如下一种或多种功能：函数入口地址、函数名信息、参数调用参数信息、返回值信息。